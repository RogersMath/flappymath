<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Equations</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #333;
            font-family: 'Press Start 2P', cursive; /* Retro gaming font */
            color: white;
            user-select: none; /* Prevent text selection */
            flex-direction: row; /* Default for desktop */
        }

        #main-wrapper {
            display: flex;
            flex-direction: row; /* Default for desktop */
            justify-content: center;
            align-items: center;
            width: auto; /* Adjusts to content */
            height: auto; /* Adjusts to content */
        }

        #game-container {
            width: 800px; /* Game resolution for desktop */
            height: 600px;
            background: linear-gradient(to bottom, #87CEEB, #5C94D1); /* Sky blue gradient */
            border: 4px solid #555;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border-radius: 8px;
        }

        #ground {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 60px; /* Height of the ground */
            background: linear-gradient(to top, #7C4F2A, #A0673A); /* Brown ground */
            border-top: 4px solid #663D1D;
            z-index: 15; /* Above obstacles */
        }

        #math-bot {
            position: absolute;
            width: 90px; /* Increased width for desktop to comfortably fit expressions */
            height: 50px; /* Desktop size */
            background-color: #FFD700; /* Gold/Yellow */
            border: 3px solid #DAA520; /* Darker gold */
            border-radius: 8px;
            left: 100px; /* Fixed horizontal position */
            top: 250px; /* Initial vertical position */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            color: #333;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            transition: background-color 0.1s ease-out, transform 0.05s ease-out; /* Smooth transition for flash */
            z-index: 10;
        }

        #math-bot.flash-green {
            background-color: #90EE90; /* Light green */
            border-color: #3CB371; /* Medium Sea Green */
            transform: scale(1.05); /* Slight bounce */
        }

        #math-bot.flash-red {
            background-color: #FF6347; /* Tomato */
            border-color: #DC143C; /* Crimson */
            transform: scale(0.95); /* Slight stutter/shrink */
        }

        #expression-display {
            padding: 5px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 4px;
            text-align: center;
            white-space: nowrap; /* Crucial fix: Prevents text from wrapping */
        }

        .obstacle {
            position: absolute;
            width: 80px; /* Desktop width of the "gate" */
            background-color: #228B22; /* Forest Green */
            border: 3px solid #1E711E; /* Darker green */
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
            z-index: 5;
            bottom: 0; /* Always anchored to the bottom */
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
        }

        #score-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 30px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 20;
            background-color: rgba(0,0,0,0.4);
            padding: 5px 15px;
            border-radius: 5px;
        }

        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            font-weight: bold;
            z-index: 100;
            text-align: center;
            opacity: 0; /* Start hidden */
            pointer-events: none; /* Don't block clicks when hidden */
            transition: opacity 0.5s ease-in-out;
        }

        #game-over-screen.show {
            opacity: 1;
            pointer-events: auto;
        }

        #final-score {
            font-size: 60px;
            margin: 20px 0;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.7);
        }

        #restart-button {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            font-family: 'Press Start 2P', cursive;
        }

        #restart-button:hover {
            background-color: #45a049;
        }

        #pause-button {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 8px 15px;
            font-size: 18px;
            background-color: rgba(0,0,0,0.4);
            color: white;
            border: 2px solid #777;
            border-radius: 5px;
            cursor: pointer;
            z-index: 20;
            font-family: 'Press Start 2P', cursive;
            transition: background-color 0.2s, border-color 0.2s;
        }

        #pause-button:hover {
            background-color: rgba(0,0,0,0.6);
            border-color: #fff;
        }

        #pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 50px;
            font-weight: bold;
            z-index: 90; /* Below game over, above everything else */
            pointer-events: none; /* Allow clicks to pass through when not shown */
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        #pause-overlay.show {
            opacity: 1;
            pointer-events: auto; /* Block clicks when shown */
        }

        /* --- Touchpad Styles (Default: Hidden) --- */
        #touchpad-container {
            display: none; /* Hidden by default on desktop */
            background-color: #222;
            padding: 10px;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            border-radius: 8px;
        }

        .touchpad-button {
            width: 80px;
            height: 80px;
            margin: 5px;
            background-color: #555;
            color: white;
            border: 2px solid #777;
            border-radius: 8px;
            font-family: 'Press Start 2P', cursive;
            font-size: 36px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        .touchpad-button:active {
            background-color: #777;
            transform: scale(0.95);
        }

        /* --- Mobile Styles --- */
        @media (max-width: 768px) {
            body {
                flex-direction: column;
                justify-content: flex-start; /* Stack content from top */
            }

            #main-wrapper {
                flex-direction: column;
                width: 100vw; /* Take full viewport width */
                height: 100vh; /* Take full viewport height */
            }

            #game-container {
                width: 100%; /* Full width on mobile */
                height: 70vh; /* 70% of viewport height for game */
                border: none; /* Remove border for full screen feel */
                border-radius: 0;
                box-shadow: none;
            }

            #math-bot {
                width: 65px; /* Increased width for mobile to fit expressions */
                height: 40px;
                font-size: 18px;
                left: 60px; /* Adjust horizontal position for smaller screens */
            }

            .obstacle {
                width: 60px; /* Smaller width for mobile */
            }

            #score-display {
                font-size: 24px;
                padding: 3px 10px;
            }

            #game-over-screen {
                font-size: 30px;
            }

            #final-score {
                font-size: 40px;
            }

            #restart-button {
                padding: 10px 20px;
                font-size: 18px;
            }

            #pause-button {
                font-size: 14px;
                padding: 6px 12px;
                top: 10px;
                right: 10px;
            }

            #pause-overlay {
                font-size: 40px;
            }

            /* Show and style touchpad for mobile */
            #touchpad-container {
                display: grid;
                grid-template-columns: repeat(3, 1fr); /* 3 columns */
                grid-template-rows: repeat(3, 1fr); /* 3 rows */
                width: 100%;
                height: 30vh; /* 30% of viewport height for touchpad */
                box-sizing: border-box; /* Include padding in height */
                padding: 10px;
                border-radius: 0;
            }

            .touchpad-button {
                width: auto; /* Take available grid space */
                height: auto;
                margin: 5px;
                font-size: 28px;
            }
        }
    </style>
</head>
<body>
    <div id="main-wrapper">
        <div id="game-container">
            <div id="ground"></div>
            <div id="math-bot">
                <span id="expression-display"></span>
            </div>
            <div id="score-display">Score: 0</div>
            <button id="pause-button">Pause</button>
            <div id="pause-overlay">PAUSED</div>
            <div id="game-over-screen">
                Game Over!
                <div id="final-score">Score: 0</div>
                <button id="restart-button">Restart Game</button>
            </div>
        </div>

        <div id="touchpad-container">
            <button class="touchpad-button" data-value="1">1</button>
            <button class="touchpad-button" data-value="2">2</button>
            <button class="touchpad-button" data-value="3">3</button>
            <button class="touchpad-button" data-value="4">4</button>
            <button class="touchpad-button" data-value="5">5</button>
            <button class="touchpad-button" data-value="6">6</button>
            <button class="touchpad-button" data-value="7">7</button>
            <button class="touchpad-button" data-value="8">8</button>
            <button class="touchpad-button" data-value="9">9</button>
        </div>
    </div>

    <script>
        const gameContainer = document.getElementById('game-container');
        const mathBot = document.getElementById('math-bot');
        const expressionDisplay = document.getElementById('expression-display');
        const scoreDisplay = document.getElementById('score-display');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreDisplay = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-button');
        const ground = document.getElementById('ground');
        const touchpadButtons = document.querySelectorAll('.touchpad-button');
        const pauseButton = document.getElementById('pause-button');
        const pauseOverlay = document.getElementById('pause-overlay');

        // --- AudioContext Variables ---
        let audioContext;
        const audioBuffers = {}; // Stores decoded AudioBuffer objects
        let musicSource = null; // Current AudioBufferSourceNode for background music
        let musicGainNode = null; // GainNode for background music volume

        // Game constants (will be initialized/updated in updateGameConstants)
        let GAME_WIDTH;
        let GAME_HEIGHT;
        let MATH_BOT_WIDTH;
        let MATH_BOT_HEIGHT;
        let GROUND_HEIGHT;
        let OBSTACLE_WIDTH;
        let MIN_OBSTACLE_HEIGHT; // Minimum height of the bottom obstacle
        let MAX_OBSTACLE_CLEARANCE; // Max space from ground the *top* of obstacle can be
        const OBSTACLE_SPAWN_INTERVAL = 2000; // milliseconds between new obstacles

        // Mobile specific constants for JS calculations (matching CSS where applicable)
        const MOBILE_MAX_WIDTH = 768; // Matches CSS media query breakpoint
        const MATH_BOT_WIDTH_DESKTOP = 90; // Increased width for desktop to fit expressions
        const MATH_BOT_HEIGHT_DESKTOP = 50;
        const OBSTACLE_WIDTH_DESKTOP = 80;
        const MIN_OBSTACLE_HEIGHT_DESKTOP = 50;
        const MAX_OBSTACLE_CLEARANCE_DESKTOP = 180; // Min vertical space above obstacle for bot to fly

        const MATH_BOT_WIDTH_MOBILE = 65; // Increased width for mobile
        const MATH_BOT_HEIGHT_MOBILE = 40;
        const OBSTACLE_WIDTH_MOBILE = 60;
        const MIN_OBSTACLE_HEIGHT_MOBILE = 40;
        const MAX_OBSTACLE_CLEARANCE_MOBILE = 120; // Smaller clearance for mobile

        // Game variables (will be initialized in startGame)
        let gameStarted = false;
        let gameOver = false;
        let isPaused = false; // New state variable for pause
        let mathBotY;
        let mathBotVelocity;
        let score;
        let currentExpression;
        let correctAnswer;
        let obstacles = [];
        let gameSpeed;
        let gravity;
        let flapStrength;
        let downwardNudge;
        let lastObstacleSpawnTime;
        let animationFrameId; // To control requestAnimationFrame

        // --- Audio Functions ---
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            // Resume context if it's suspended (common for initial user interaction)
            if (audioContext.state === 'suspended') {
                audioContext.resume().catch(e => console.error("AudioContext resume failed:", e));
            }
        }

        async function loadAudio(url, name) {
            try {
                const response = await fetch(url);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                audioBuffers[name] = audioBuffer;
            } catch (error) {
                console.error(`Error loading audio file ${url}:`, error);
            }
        }

        function playShortSound(bufferName) {
            if (!audioContext || !audioBuffers[bufferName]) {
                console.warn(`Audio buffer for '${bufferName}' not loaded or AudioContext not initialized.`);
                return;
            }
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffers[bufferName];
            source.connect(audioContext.destination);
            source.start(0); // Play immediately
        }

        function startBackgroundMusic() {
            if (!audioContext || !audioBuffers['backgroundMusic']) {
                console.warn("Background music buffer not loaded or AudioContext not initialized.");
                return;
            }

            // Stop existing music source if any
            if (musicSource) {
                musicSource.stop();
                musicSource.disconnect();
            }

            // Create new source and gain node
            musicSource = audioContext.createBufferSource();
            musicGainNode = audioContext.createGain();

            musicSource.buffer = audioBuffers['backgroundMusic'];
            musicSource.loop = true; // Loop the music
            musicGainNode.gain.value = 0.3; // Set desired volume

            musicSource.connect(musicGainNode);
            musicGainNode.connect(audioContext.destination);

            musicSource.start(0); // Play immediately
        }

        function stopBackgroundMusic() {
            if (musicSource) {
                musicSource.stop();
                musicSource.disconnect(); // Disconnect to clean up
                musicSource = null; // Clear reference
            }
        }

        // Wrapper for game logic calls to play sounds
        function playSound(soundName) {
            playShortSound(soundName);
        }

        function startMusic() {
            startBackgroundMusic();
        }

        function stopMusic() {
            stopBackgroundMusic();
        }

        // --- Update Game Dimensions based on screen size ---
        function updateGameConstants() {
            GAME_WIDTH = gameContainer.offsetWidth;
            GAME_HEIGHT = gameContainer.offsetHeight;

            const isMobile = window.innerWidth <= MOBILE_MAX_WIDTH;

            // Update Math-Bot and Obstacle dimensions for JS calculations
            MATH_BOT_WIDTH = isMobile ? MATH_BOT_WIDTH_MOBILE : MATH_BOT_WIDTH_DESKTOP;
            MATH_BOT_HEIGHT = isMobile ? MATH_BOT_HEIGHT_MOBILE : MATH_BOT_HEIGHT_DESKTOP;
            OBSTACLE_WIDTH = isMobile ? OBSTACLE_WIDTH_MOBILE : OBSTACLE_WIDTH_DESKTOP;
            MIN_OBSTACLE_HEIGHT = isMobile ? MIN_OBSTACLE_HEIGHT_MOBILE : MIN_OBSTACLE_HEIGHT_DESKTOP;
            MAX_OBSTACLE_CLEARANCE = isMobile ? MAX_OBSTACLE_CLEARANCE_MOBILE : MAX_OBSTACLE_CLEARANCE_DESKTOP;

            // Ensure Math-Bot's CSS dimensions match the JS values for accurate collision
            mathBot.style.width = `${MATH_BOT_WIDTH}px`;
            mathBot.style.height = `${MATH_BOT_HEIGHT}px`;

            // Ground height is fixed in CSS, grab its current computed height
            GROUND_HEIGHT = ground.offsetHeight;
        }

        // --- Visual Feedback Functions ---
        function applyFlash(colorClass) {
            mathBot.classList.add(colorClass);
            setTimeout(() => {
                mathBot.classList.remove(colorClass);
            }, 100); // Flash duration
        }

        // --- Math Logic ---
        function generateExpression() {
            let num1, num2, operator, result;

            // Randomly choose addition or subtraction
            if (Math.random() < 0.5) { // Addition
                operator = '+';
                // num1: 1-8, num2: 1 to (9 - num1) to ensure sum is 1-9
                num1 = Math.floor(Math.random() * 8) + 1; // 1 to 8
                num2 = Math.floor(Math.random() * (9 - num1)) + 1; // 1 to (9 - num1)
                result = num1 + num2;
            } else { // Subtraction
                operator = '-';
                // num1: 2-9, num2: 1 to (num1 - 1) to ensure result is 1-9
                num1 = Math.floor(Math.random() * 8) + 2; // 2 to 9
                num2 = Math.floor(Math.random() * (num1 - 1)) + 1; // 1 to (num1 - 1)
                result = num1 - num2;
            }

            currentExpression = `${num1} ${operator} ${num2}`;
            correctAnswer = result;
            expressionDisplay.textContent = currentExpression;
        }

        // --- Obstacle Logic ---
        function createObstacle() {
            // Calculate max possible height for the bottom obstacle
            // It must leave enough room for the bot to fly over, plus some buffer.
            const maxAllowedObstacleHeight = GAME_HEIGHT - GROUND_HEIGHT - MATH_BOT_HEIGHT - MAX_OBSTACLE_CLEARANCE;

            // Random height for the obstacle, clamped by min and max allowed
            const obstacleHeight = Math.floor(Math.random() * (maxAllowedObstacleHeight - MIN_OBSTACLE_HEIGHT + 1)) + MIN_OBSTACLE_HEIGHT;

            const obstacleX = GAME_WIDTH;

            // Create the single bottom obstacle div
            const obstacleDiv = document.createElement('div');
            obstacleDiv.classList.add('obstacle'); // Only one class now
            obstacleDiv.style.width = `${OBSTACLE_WIDTH}px`;
            obstacleDiv.style.height = `${obstacleHeight}px`;
            obstacleDiv.style.left = `${obstacleX}px`;
            gameContainer.appendChild(obstacleDiv);

            obstacles.push({
                x: obstacleX,
                height: obstacleHeight, // Store the height of this single obstacle
                element: obstacleDiv, // Reference to the DOM element
                passed: false // To track if Math-Bot has passed for scoring
            });
        }

        function updateObstacles() {
            obstacles.forEach(obstacle => {
                obstacle.x -= gameSpeed;
                obstacle.element.style.left = `${obstacle.x}px`;

                // Check if Math-Bot has passed the obstacle's origin (left edge of Math-Bot passed right edge of obstacle)
                if (!obstacle.passed && mathBot.offsetLeft > obstacle.x + OBSTACLE_WIDTH) {
                    score += 100; // Bonus points for passing
                    scoreDisplay.textContent = `Score: ${score}`;
                    obstacle.passed = true;
                    // Increase difficulty gradually
                    // Cap game speed, gravity increases, flap strength slightly decreases
                    if (score % 500 === 0 && gameSpeed < 5) {
                        gameSpeed += 0.2;
                        gravity += 0.02;
                        flapStrength -= 0.3; // Less drastic reduction in flap strength
                        if (flapStrength < 4) flapStrength = 4; // Minimum flap strength
                    }
                }
            });

            // Remove obstacles that are off-screen
            obstacles = obstacles.filter(obstacle => {
                if (obstacle.x + OBSTACLE_WIDTH < 0) {
                    obstacle.element.remove();
                    return false;
                }
                return true;
            });

            // Spawn new obstacles
            const currentTime = Date.now();
            if (currentTime - lastObstacleSpawnTime > OBSTACLE_SPAWN_INTERVAL) {
                createObstacle();
                lastObstacleSpawnTime = currentTime;
            }
        }

        // --- Collision Detection ---
        function checkCollision() {
            // Ground collision
            if (mathBotY + MATH_BOT_HEIGHT >= GAME_HEIGHT - GROUND_HEIGHT) {
                mathBotY = GAME_HEIGHT - GROUND_HEIGHT - MATH_BOT_HEIGHT; // Snap to ground
                return true;
            }

            // Obstacle collision
            const mathBotRect = {
                x: mathBot.offsetLeft,
                y: mathBotY,
                width: MATH_BOT_WIDTH,
                height: MATH_BOT_HEIGHT
            };

            for (const obstacle of obstacles) {
                const obstacleX = obstacle.x;
                const obstacleWidth = OBSTACLE_WIDTH;

                // Check for horizontal overlap
                if (mathBotRect.x + mathBotRect.width > obstacleX && mathBotRect.x < obstacleX + obstacleWidth) {
                    // Check for vertical overlap with the top of the bottom obstacle
                    // The top of the bottom obstacle is at (GAME_HEIGHT - GROUND_HEIGHT - obstacle.height)
                    if (mathBotRect.y + mathBotRect.height > (GAME_HEIGHT - GROUND_HEIGHT - obstacle.height)) {
                        return true;
                    }
                }
            }

            return false;
        }

        // --- Game Loop ---
        function gameLoop() {
            if (gameOver || isPaused) return; // Exit if game is over or paused

            // Update Math-Bot position
            mathBotVelocity += gravity;
            mathBotY += mathBotVelocity;

            // Clamp Math-Bot Y position (prevent it from going completely off top)
            if (mathBotY < 0) {
                mathBotY = 0;
                mathBotVelocity = 0; // Stop upward movement if hitting top
            }

            mathBot.style.top = `${mathBotY}px`;

            // Update obstacles
            updateObstacles();

            // Check collisions
            if (checkCollision()) {
                endGame();
                return;
            }

            // Update horizontal score based on distance travelled (game speed)
            score += Math.round(gameSpeed * 0.1); // Small continuous score
            scoreDisplay.textContent = `Score: ${score}`;

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- Game Control Functions ---
        function startGame() {
            if (gameStarted) return; // Prevent starting multiple times
            gameStarted = true;
            gameOver = false;
            isPaused = false; // Ensure game is not paused when starting

            // Initialize/resume AudioContext on first game start
            initAudioContext();

            // Update constants based on current screen size
            updateGameConstants();

            // Initial values
            mathBotY = GAME_HEIGHT / 2 - MATH_BOT_HEIGHT / 2;
            mathBotVelocity = 0;
            score = 0;
            obstacles = [];
            gameSpeed = 2; // Initial horizontal speed
            gravity = 0.005;
            flapStrength = 0.8; // How much bot jumps with correct answer
            downwardNudge = 0.25; // How much bot drops with incorrect answer
            lastObstacleSpawnTime = Date.now();

            scoreDisplay.textContent = `Score: ${score}`;
            mathBot.style.top = `${mathBotY}px`;
            mathBot.style.left = `${GAME_WIDTH * 0.125}px`; // Keep bot at 1/8th width position
            gameOverScreen.classList.remove('show');
            pauseOverlay.classList.remove('show'); // Hide pause overlay
            pauseButton.textContent = 'Pause'; // Reset pause button text
            pauseButton.style.display = 'block'; // Ensure pause button is visible

            // Remove any existing obstacles from previous game
            document.querySelectorAll('.obstacle').forEach(el => el.remove());

            generateExpression();
            createObstacle(); // Create the first obstacle

            startMusic();
            gameLoop();
        }

        function endGame() {
            gameOver = true;
            gameStarted = false;
            cancelAnimationFrame(animationFrameId); // Stop the game loop
            stopMusic();
            playSound('crashSound'); // Play crash sound

            finalScoreDisplay.textContent = `Score: ${score}`;
            gameOverScreen.classList.add('show');
            pauseButton.style.display = 'none'; // Hide pause button on game over
        }

        function restartGame() {
            // No need to show pause button here, startGame handles it
            startGame();
        }

        function togglePause() {
            if (!gameStarted || gameOver) return; // Only allow pausing during an active game

            isPaused = !isPaused;
            if (isPaused) {
                cancelAnimationFrame(animationFrameId); // Stop the game loop
                pauseButton.textContent = 'Resume';
                pauseOverlay.classList.add('show');
                stopMusic(); // Pause music
                if (audioContext.state === 'running') { // Pause AudioContext itself if running
                    audioContext.suspend().catch(e => console.error("AudioContext suspend failed:", e));
                }
            } else {
                // Resume AudioContext first if suspended
                if (audioContext.state === 'suspended') {
                    audioContext.resume().catch(e => console.error("AudioContext resume failed:", e));
                }
                animationFrameId = requestAnimationFrame(gameLoop); // Resume the game loop
                pauseButton.textContent = 'Pause';
                pauseOverlay.classList.remove('show');
                startMusic(); // Resume music
            }
        }

        // --- Input Handling Logic ---
        function handleAnswerInput(inputNumber) {
            if (gameOver || isPaused) return; // Ignore input if game is over or paused

            // Initialize/resume AudioContext on first user interaction if not already
            initAudioContext();

            if (!gameStarted) {
                startGame(); // Start game on the first valid key press
                return;
            }

            if (inputNumber === correctAnswer) {
                // Correct answer
                mathBotVelocity = -flapStrength; // Upward boost
                playSound('correctSound'); // Play correct sound
                applyFlash('flash-green');
                score += 50; // Bonus points for correct answer
                generateExpression(); // New problem
            } else {
                // Incorrect answer
                mathBotVelocity += downwardNudge; // Slight downward nudge
                playSound('incorrectSound'); // Play incorrect sound
                applyFlash('flash-red');
                // Expression remains until correct answer
            }
        }

        // --- Event Listeners ---
        document.addEventListener('keydown', (e) => {
            const pressedKey = parseInt(e.key);
            if (!isNaN(pressedKey) && pressedKey >= 1 && pressedKey <= 9) {
                handleAnswerInput(pressedKey);
            } else if (e.key === 'p' || e.key === 'P' || e.key === 'Escape') { // Add P/Escape for pause
                togglePause();
            }
        });

        touchpadButtons.forEach(button => {
            button.addEventListener('click', () => {
                const value = parseInt(button.dataset.value);
                handleAnswerInput(value);
            });
        });

        restartButton.addEventListener('click', restartGame);
        pauseButton.addEventListener('click', togglePause);

        // Initial setup on load (don't start the game until first key press)
        document.addEventListener('DOMContentLoaded', async () => {
            // Initialize AudioContext immediately so audio files can start loading
            initAudioContext(); // This will create the context, but it might be suspended.

            // Load all audio files
            await Promise.all([
                loadAudio('https://www.soundjay.com/button/button-3.wav', 'correctSound'),
                loadAudio('https://www.soundjay.com/misc/fail-buzzer-01.wav', 'incorrectSound'),
                loadAudio('https://www.soundjay.com/transport/car-crash-1.wav', 'crashSound'),
                loadAudio('./backgroundMusic.mp3', 'backgroundMusic') // User's local file
            ]);

            updateGameConstants(); // Set initial dimensions
            mathBotY = GAME_HEIGHT / 2 - MATH_BOT_HEIGHT / 2; // Position Math-Bot initially
            mathBot.style.top = `${mathBotY}px`;
            mathBot.style.left = `${GAME_WIDTH * 0.125}px`; // Keep bot at 1/8th width position
            // Display a welcome message
            expressionDisplay.textContent = "Press 1-9 to Start!";
            scoreDisplay.textContent = "Score: 0";
            pauseButton.style.display = 'block'; // Ensure pause button is visible initially
        });

        // Re-evaluate game constants on window resize to ensure responsiveness
        window.addEventListener('resize', () => {
            updateGameConstants();
            // Reposition Math-Bot in case GAME_HEIGHT changed significantly
            mathBotY = GAME_HEIGHT / 2 - MATH_BOT_HEIGHT / 2;
            mathBot.style.top = `${mathBotY}px`;
            mathBot.style.left = `${GAME_WIDTH * 0.125}px`;
        });
    </script>
</body>
</html>
